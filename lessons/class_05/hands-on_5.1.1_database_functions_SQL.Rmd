---
title: "Manipulation of data tables"
subtitle: "sampling"
output:
  html_document:
    df_print: paged
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->

```{r setup}
library(tidyverse)
#

# datasets
library(nycflights13)
library(Lahman)
```

## Objectives

* Using SQL: understand how to join tables

* Using SQL: understand the primary types of mutating and filtering joins




## 1. Joins with HR data

For this exercise, we will use the same database as last week's endeavour, but instead of the functions in R's {dplyr} package, we will use the ubiquitous database interface language SQL.
 
The Lahman baseball database contains a comprehensive listing of annual summaries for the major leagues of baseball, going back to 1871. 

For this exercise, we will use three of the tables:

* "People" -- all players

* "Salaries" -- an incomplete list of the annual summary of each player's compensation.
 
* "Batting" -- the annual summary of each player's batting. (Note: players who were traded between teams mid-season show up with a record for their performance of each team.)

Think of these as the sorts of files that you would find in any human resources department: 

* the People file contains the personal details of each individual employed by the enterprise.

* Batting contains in-depth performance measures for the employees in a specific task group

* Salaries is an incomplete tables showing the compensation of some of the employees


### 1a. Read in the three tables

Relational database systems (RDBMS) don't load the entire database into your computer's memory, but instead send the instructions to the database and extract only the variables and records that you specify. This makes them more efficient when working with large datasets—harnessing the computing power and memory of the database server, rather than pushing your desktop machine to it's limits.


### 1b. Understanding the tables


> i. What is the key variable that links the three tables?

A: playerID

The ID is unique so they don’t need any other way to identify the players. Any other table can be joined with the players table for more information about a player.
 
> ii. Which table has the primary key? What is the reason behind your answer?

A: `People` has the primary key. It lists all individual players. The other dataframes potentially include multiple entries for each player ID. For example, a player might be traded mid-season and have two records in `Batting`, one for each team played for that season. 

> iii. Why would the designers of the table put only one variable in the Batting table that identifies a player?

A: Since all of the data in `People` is constant (name, birthdate, etc) there is no need to repeat those variables in the other tables where there are multiple records for the same player. It also means that this consistent data only has to be edited in one location, not across all of the tables.

In this short chunk, all of the variables (indicated by the asterix "*", acting as a wildcard) in the `Batting` table are selected, and then filtered to include only 2019 records.

Note the semi-colon at the end to close the script.

```{sql}

SELECT * 
FROM BATTING
WHERE yearID = 2019;


```

This second example shows how selection of the `playerID`, `teamID` and `R` (for Runs scored) variables would be chosen.

```{sql}

SELECT playerID, teamID, R
FROM BATTING
WHERE yearID = 2019;


```


### 1c. Aggregate functions

Aggregate functions like `sum()` or `count()` are an important part of creating data summaries.

The first script counts the number of players on each team; the second calculates the number of runs each team scored in 2019.

```{sql}

-- calculate number of players on each team 
SELECT teamID, count(teamID)  
FROM BATTING 
WHERE yearID = 2019
GROUP BY teamID;

-- calculate number of runs each team scored
SELECT teamID, sum(R)  
FROM BATTING 
WHERE yearID = 2019
GROUP BY teamID;

```


### 1d. Joins

Join the tables in such a way so that you can tabulate the number of batters that played on each team in 2019, by birth country.

To accomplish this in R, the first {dplyr} pipe that filters to the year and joins the tables looked like this:

```{r}
MLB_HR_data <- Batting %>% 
  filter(yearID == 2019) %>% 
  left_join(People, by = "playerID")

```


In SQL, we use `SELECT` to select the columns we want (the same term as {dplyr}). The asterix "*" is a wildcard to select all the tables.

`FROM` indicates which tables. 

The joins are named using terms similar to {dplyr}. This left join will return all of the records from the `batting` table, and the variables from `people` where there is a match (in the case of the Lahman database, this is all of them).

To indicate the key variable for the join, we use `ON`. Note that we specify the table and the variable, separated by a period.

And finally, the filtering by year uses the SQL function `WHERE`.

So it would be:

```{sql}
-- use a left join
-- select all columns from both tables with "*"
SELECT * 
FROM BATTING LEFT JOIN PEOPLE
ON BATTING.playerID = PEOPLE.playerID
WHERE yearID = 2019;
```

In this second example, the `SELECT` function is used to specify the columns we want in the final table. Note that columns from both tables can be named.

This example uses an `INNER JOIN`, returning the cases where there is a match in both tables.

```{sql}

-- use an inner join
-- select specific columns from both tables
SELECT nameFirst, nameLast, playerID, yearID, teamID, R 
FROM BATTING INNER JOIN PEOPLE
ON BATTING.playerID = PEOPLE.playerID
WHERE yearID = 2019;

```

Back to R: with our combined tables, we use the `group_by()` function to assign the variables that we want in our table, and then the `tally()` function to count the number of rows. The last line sorts the tabluation, first by team and then in descending order the counts.


```{r}
MLB_HR_data %>% 
  group_by(teamID, birthCountry) %>% 
  tally() %>% 
  arrange(teamID, desc(n))
```

A single R pipe that starts with the two tables and generates our summary would combine the contents of the two chunks:

```{r}
Batting %>% 
  filter(yearID == 2019) %>% 
  left_join(People, by = "playerID") %>% 
  group_by(teamID, birthCountry) %>% 
  tally() %>% 
  arrange(teamID, desc(n))
```


The SQL function to accomplish the same end is somewhat different. We start by selecting the three variables we want in our summary table: `teamID`, `birthCountry`, and using the aggregate function `COUNT()` to tally the number of rows. Note that the two variables we are working with are from different tables.

The next lines have the `INNER JOIN` function we saw earlier, followed by the filter on `yearID`.

The final line shows the `GROUP BY` function that implements the aggregation.


```{sql}
-- grouping join to calculate number of players on each team by country of birth
SELECT teamID, birthCountry, COUNT(birthCountry)
FROM BATTING INNER JOIN PEOPLE
ON BATTING.playerID = PEOPLE.playerID
WHERE yearID = 2019
GROUP BY teamID, birthCountry;

```


This next chunk expands the one above.

In the first line, the tally gets renamed `n` using the `AS` function.

The last lines add the ordering, first the teams alphabetically (ascending, or `ASC`), then the counts from largest to smallest (descending, `DESC`).

```{sql}

-- grouping join to calculate number of players on each team by country of birth
-- add sort (ORDER BY)
SELECT teamID, birthCountry, count(birthCountry) AS n
FROM BATTING INNER JOIN PEOPLE
ON BATTING.playerID = PEOPLE.playerID
WHERE yearID = 2019
GROUP BY teamID, birthCountry
ORDER BY
  teamID ASC, 
  n DESC;



```



### 2a. What was the Blue Jays' ROI?

Let's join the tables to calculate how much it cost the Blue Jays per run scored in 2016 (the last year for which there is salary data). Remember that this is incomplete, as the salary data is incomplete.

```{r}
jays_salaries <- Salaries %>%
  filter(yearID == 2016,
         teamID == "TOR") %>% 
  arrange(desc(salary))

jays_batting <- Batting %>% 
  filter(yearID == 2016,
         teamID == "TOR")

jays_roi <- jays_salaries %>% 
  left_join(jays_batting, by = "playerID")

jays_roi %>% 
  summarise(dollars = sum(salary),
            runs = sum(R),
            roi = dollars/runs)

```


The SQL version:

```{sql}


SELECT  teamID, yearID, sum(R), sum(salary), sum(salary)/sum(R) AS ROI  
FROM BATTING 

INNER JOIN PEOPLE
ON BATTING.playerID = PEOPLE.playerID

INNER JOIN SALARIES
ON PEOPLE.playerID = SALARIES.playerID
AND BATTING.yearID = SALARIES.yearID
AND BATTING.teamID = SALARIES.teamID

WHERE BATTING.yearID = 2016
AND BATTING.teamID = "TOR"

GROUP BY BATTING.teamID, BATTING.yearID;


```



***

## REFERENCE

This hands-on exercise draws heavily on the following sources:

* ["Relational data" at _R for Data Science_](https://r4ds.had.co.nz/relational-data.html)

* ["Join two tables" at the STAT545 site](https://stat545.com/join-cheatsheet.html)

{dplyr} reference page: https://dplyr.tidyverse.org/

* ["Two-table verbs", article at the {dplyr} website](https://dplyr.tidyverse.org/articles/two-table.html)

* ["Join two tbls together", part of the {dplyr} reference pages](https://dplyr.tidyverse.org/reference/join.html)



## Other references


### SQLite

[SQLite tutorial](https://www.sqlitetutorial.net/)

* [SQLite functions](https://www.sqlitetutorial.net/sqlite-functions/)



### SQL

Thomas Nield, _Getting Started with SQL: A Hands-On Approach for Beginners_ (2016)

* Chapter 2, "Databases"

* Chapter 9, "Database design"

* Installing SQLite: Chapter 3, "SQLite"

* [UVic Library link](https://proquestcombo-safaribooksonline-com.ezproxy.library.uvic.ca/9781491938607?ar&orpq&email=oJbr4Ho8VLXz0zbFzjLK2g%3d%3d&tstamp=1600913295&id=2C359E41B596290424E03BF0F243BBA36BFDDBFA)


### SQL from R Markdown

[_R Markdown: The Definitive Guide_, 2.7.3 SQL](https://bookdown.org/yihui/rmarkdown/language-engines.html#sql) by Yihui Xie, J. J. Allaire, Garrett Grolemund

* instructions on how to set up your R Markdown (in RStudio) so that you can run SQL language chunks, including using SQLite


