---
title: "BIDA 405 - week 4"
subtitle: "homework assignment #4: solutions"
author: "Martin Monkman"
date: "2020/09/20"
output: html_notebook
---

```{r setup}

library(tidyverse)

library(validate)

library(nycflights13)
```

# A. strings with regular expressions 

In the in-class example of regular expressions, we saw a regex to identify Canadian postal codes. However, the example was generalized to include all the letters of the alphabet. In reality, postal codes:

* do not include the letters D, F, I, O, Q or U. (These are letters that could be mistaken for numbers.)

* the first position also does not make use of the letters W or Z.

### Q1. Write a case-insensitive regular expression to test for valid Canadian postal codes. Test it on the following lists:


```{r}
# postal code lists
valid_pc <- c(
  "a1a1a1", # Lower Battery Road, St. John's NL
  "a1a 1a2", # Middle Battery Road
  "a1a-1a3", # East Middle Battery Road
  "H0H0H0", # North Pole
  "K1M 1M4", # 24 Sussex Drive, Ottawa (Prime Minister's residence)
  "M5W-1E6", # CBC Toronto
  "T2P 1j9", # Calgary Tower
  "j8v 2L8", # British Columbia Parliament Buildings
  "V8P5C2", # UVic
  "X1A-0A1" # Yellowknife, NT
              )

invalid_pc <- c("H0H OH0", # capital O--letter for number
                "W1A 1A1", # W in first position
                "A1A_1A3" # underscore, not hyphen
                )

```


```{r}

# solution
postalcode <- "(?i)^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ -]?\\d[ABCEGHJ-NPRSTV-Z]\\d$(?-i)"


str_detect(valid_pc, postalcode)

str_detect(invalid_pc, postalcode)

```


## Q2. More postal codes

Following the pattern of letter-number-letter (space) number-letter-number in Canadian postal codes, there are 676,000 possible postal codes in British Columbia alone, where the first letter is "V".

The file "bc_pc.csv" contains every one of these possible codes.

```{r}
bc_pc <- read_csv("bc_pc.csv")

```

However, as we saw in the first part of this question, some of the possible codes are not valid, because some letters of the alphabet are not used. 

### Q2a. Test to see how many of the possible B.C. postal codes are invalid (that is, use letters that are not authorized.) 

```{r}
# solution #1

# all Canadian postal codes
postalcode_regex <- "(?i)^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ -]?\\d[ABCEGHJ-NPRSTV-Z]\\d$(?-i)"
# BC specific (first letter V)
postalcode_regex <- "(?i)^V\\d[ABCEGHJ-NPRSTV-Z][ -]?\\d[ABCEGHJ-NPRSTV-Z]\\d$(?-i)"

bc_pc_test <- bc_pc %>% 
  mutate(pc_clean =
         str_detect(postalcode, postalcode_regex)
  )

bc_pc_test %>% 
  group_by(pc_clean) %>% 
  tally()
```

```{r}
# solution #2
# BC specific but test for wrong letters
# D, F, I, O, Q or U

# note: solution has two smaller regex chunks joined by a Boolean operator (or)

# BC specific (first letter V)
null_postalcode_regex <- c("^.\\d[DFIOQU]|[DFIOQU]\\d$")

postalcode <- "V1D 1D1"
str_detect(postalcode, null_postalcode_regex)

bc_pc_test_null <- bc_pc %>% 
  mutate(pc_null =
         str_detect(postalcode, null_postalcode_regex)
  )

bc_pc_test_null %>% 
  group_by(pc_null) %>% 
  tally()

sum(bc_pc_test_null$pc_null)

bc_pc_test_null %>% 
  summarise(n = sum(pc_null))


```

### Q2b. Using the _valid_ postal codes from "bc_pc.csv", create a list with the unique Forward Sortation Areas (FSAs)

Canada Post uses the first three digits of postal codes as higher-level aggregation groups. In the same way that the letter "V" is used as the first letter in all postal codes in British Columbia (and in no other province), the FSA groups postal codes.

An example: the postal code of the Continuing Studies Department at UVic is "V8P 5C2". The FSA is "V8P".

```{r}
# solution
bc_pc_test2 <- bc_pc_test %>% 
  filter(pc_clean == TRUE) %>% 
  mutate(fsa = str_sub(postalcode, 1, 3)) %>% 
  distinct(fsa)

bc_pc_test2

# another approach using `group_by()`
bc_pc_test %>% 
  filter(pc_clean == TRUE) %>% 
  mutate(fsa = str_sub(postalcode, 1, 3)) %>% 
  group_by(fsa) %>% 
  tally()

```


## Q3. Joins - flights

In this example, we will add the name of the airline to the `flights` table. First, we will make a smaller version of the `flights` table by selecting a few of the variables.

```{r}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```

To this table, add the name of the airline found in the table `airlines`.

* which is the key variable that you use for the join?


```{r}
data("flights")
# solution
left_join(flights2, airlines, by = "carrier")
# alternate version, using a pipe
flights2 %>%
  left_join(airlines, by = "carrier")
```


-30-
