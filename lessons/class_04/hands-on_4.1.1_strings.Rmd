---
title: "Validation and Cleaning"
subtitle: "4: cleaning character strings"
output:
  html_document:
    df_print: paged
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->

```{r setup}
library(tidyverse)

```



### Cleaning strings

> Strings are not glamorous, high-profile components of R, but they do play a big role in many data cleaning and preparation tasks. 
—{stringr} reference page

R provides some robust tools for working with characters strings. In particular, the {stringr} package is very flexible.

{stringr} reference page: https://stringr.tidyverse.org/


```{r setup}

library(tidyverse)
#
library(stringr)  # {stringr} is part of the tidyverse, but not a core package that loads with {tidyverse}

```



## Objectives

* Understand the basics of regular expressions (regexps)

* Understand basic functions in {stringr} for working with strings

* Demonstrate ability to use those functions


## 1. Strings

Characters, numbers, etc that are enclosed in quotation marks become a character string.


```{r}

string1 <- "This is my 1st string!"

string1

# number stored as number
numstring1 <- 1234

# number stored as string
numstring2 <- "1234"

```

Can we add `numstring1` and `numstring2` together? No, unless we make a change to the type of variable.

```{r}

numstring1 + numstring2

as.integer(numstring2)


# number with a comma (string)
numstring3 <- "1,234"

as.integer(numstring3)

as.integer(gsub(",", "", numstring3))

```


Columns (variables) in a dataframe can be of the type "character", denoted by `chr` or `<chr>`.

Note that in this example, variable "a" and "b" are both <chr>, "c" is <dbl> and "d" (with the "L" after the number) is an integer.

```{r}

onefish <- tibble(
       a = c("12", "34"),
       b = c("12", "fish"),
       c = c(12, 34),
       d = c(12L, 34L),
)

ls.str(onefish)

onefish

```

We can convert "a" to a numeric variable, but if we try it with "b", the not-a-number gets converted to an NA.

```{r}

onefish %>% 
  mutate(a = as.numeric(a))

onefish %>% 
  mutate(b = as.numeric(b))

```


## 2. Regular expressions

>Some people, when confronted with a problem, think: “I know, I’ll use regular expressions.” Now they have two problems.
— Jamie Zawinski

See https://stringr.tidyverse.org/articles/regular-expressions.html

Also, as a handy tool: https://regex101.com/


#### - matching functions

Some useful functions:

| character | what it does |
| ---- | ---- |
| "abc" | matches "abc" |
| "[a][b][c]" | matches "abc" |
| "[abc]" | matches "a", "b", or "c" |
| "[a-c]" | matches any of "a" to "c" <br>(that is, matches "a", "b", or "c") |
| "[^abc]" | matches anything _except_ "a", "b", or "c" |
| "^" | match start of string |
| "$" | match end of string |
| "." | matches any string |


```{r}
x <- c("apple", "banana", "pear")

# which words start with "a"?
str_detect(x, "^a")

# which words have an "ea" combination?

str_detect(x, "ea")


```

### Your turn 2.1 

Which words end with "a"?

```{r}
# solution
str_view(x, "a$")


```


frequency of match

| character | what it does |
| ---- | ---- |
| "?" | 0 or 1 |
| "+" | 1 or more |
| "*" | 0 or more |


The question mark is useful for words with various spellings -- the British and American variations of words like "colour" and "neighbour".

| character | what it does |
| ---- | ---- |
| "{n}" | exactly n times |
| "{n,}" | n or more |
| "{n,m}" | between n and m times |


```{r}
# which words have a double "p"?

str_view(x, "p{2}")

```


### 2a. Special characters

**quotes**

Single and double quotes need to be "escaped" with a `\`

```{r}

double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"

double_quote
single_quote

```


* to see a representation of the string as it will print, use the function `writeLines()`

```{r}

writeLines(double_quote)

```



```{r}

string2 <- 'The 2nd string has a "quote" so it is inside single quotes'

string2

writeLines(string2)

```


**other special characters**

These also need to be escaped:

| character | what it is |
| ---- | ---- |
| "\\" | backslash |
| "\d" | any digit |
| "\n" | newline (line break) |
| "\s" | any whitespace (space, tab, newline)
| "\t" | tab |
| "\u..." | unicode characters* |


* https://en.wikipedia.org/wiki/List_of_Unicode_characters

See the help function for `?'"'`

```{r}
interrobang <- "\u2048"
interrobang

```


To make a shruggie, you need to escape the backslash

```{r}

shruggie <- glue::glue("¯\\_(ツ)_/¯")
shruggie

shruggie <- glue::glue("¯\\", "_(ツ)_", "/¯")
shruggie

```



### 2b. Postal code

Canadian postal codes follow a consistent pattern:
 - letter digit letter (space, or sometimes a hyphen) digit letter digit

The regex for this is shown below, with the component parts as follows:

* ^ : start of string

* [A-Za-z] : all the letters upper and lower case

* \\d : any numerical digit

* [ -]? : space or hyphen; "?" to make either optional (i.e. it may be there or not)

* $ : end of string


```{r}
# regex for Canadian postal codes
# ^ : start of string
# [A-Za-z] : all the letters upper and lower case
# \\d : any numerical digit
# [ -]? : space or hyphen, ? to make either optional (i.e. it may be there or not)
# $ : end of string

postalcode <- "^[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d$"

# option: (?i) : make it case insensitive
#         (?-i) : turn off insensitivity
postalcode <- "(?i)^[A-Z]\\d[A-Z][ -]?\\d[A-Z]\\d$(?-i)"

# list of postal codes
pc1 <- c("V1A2B3", "V1A 2B3", "v1a-2b3")

str_detect(pc1, postalcode)


```

Advice from the masters:

> If your regular expression gets overly complicated, try breaking it up into smaller pieces, giving each piece a name, and then combining the pieces with logical operations.
—Wickham and Grolemund, _R for Data Science_, ["Detect matches"](https://r4ds.had.co.nz/strings.html#detect-matches)


### 2c. useful {stringr} functions

See 

* reference page: [stringr.tidyverse.org](https://stringr.tidyverse.org/)

* cheat sheet: at RStudio "Cheatsheets" page https://rstudio.com/resources/cheatsheets/ 

#### - string characteristics

| function | purpose |
| ---- | ---- |
| `str_length` | numeric; returns the length of the string |
| `str_detect` | logical; returns TRUE if pattern found |
| `str_sub` | character; returns the defined subset using start and end positions |
| `str_subset` | character; returns the cases which contain a match |
| `str_which` | numeric; returns the vector location of matches |
| `str_count` | numeric; returns the number of times the pattern appears in the string |


```{r}

fruit <- c("apple", "banana", "pear", "pineapple")

str_length(fruit)       # how many characters is the string?
str_detect(fruit, "e")  # does the string have the pattern ("e")?
str_sub(fruit, 1, 2)    # starting at the first position (1), two characters (2)


```

```{r}
str_subset(fruit, "e")  # which strings have the pattern ("e")?
str_which(fruit, "e")   # which strings have the pattern ("e"), by location?

```

```{r}
str_count(fruit, "e")     # how many times does the letter "e" appear in the string?
str_count(fruit, "[aeiou]") # how many times does a vowel (a, e, i, o, or u) appear in the string?
```

#### - matching, replacing, spliting

| function | purpose |
| ---- | ---- |
| `str_locate` | numeric; gives the position of the first match |
| `str_extract` | extracts the text of the match
| `str_match` | extracts the text of the match and parts of the match within parenthesis |
| `str_replace` | replaces the matches with new text |
| `str_split` | splits up a string at the pattern |



```{r}

str_locate(fruit, "e") # where is the first e" in the string?
str_locate(fruit, "[aeiou]") # where is the first vowel in the string?

str_extract(fruit, "[aeiou]")  # which is the first vowel?

str_match(fruit, "(.)[aeiou]") # what is the first letter that comes before a vowel?

```


```{r}
str_replace(fruit, "e", "E")
```


```{r}
str_split(fruit, "e")
```


```{r}
UVic_address <- "Continuing Studies, Continuing Studies Building, 3800 Finnerty Rd, Victoria, BC, V8P 5C2"
  
str_split(UVic_address, ", ")
```

#### - convert case

{stringr} has functions to change the case of the string. See [{stringr}: Convert case of a string](https://stringr.tidyverse.org/reference/case.html)


### 3. Replace postal code with consistent layout


How can we clean up this list so that our postal codes are in a consistent format?

```{r}
# list of postal codes
pc1 <- c("V1A2B3", "V1A 2B3", "v1a-2b3")
```

One solution:

a. remove space or hyphen

```{r}

gsub(pattern = " ", replacement = "", x = pc1)
gsub(pattern = "-", replacement = "", x = pc1)

# combine the two in single regex
pc_clean <- gsub("[ -]", "", pc1)
pc_clean

```

b. all caps

```{r}
pc_clean <- str_to_upper(pc_clean)
pc_clean
```



---

## REFERENCE

[{stringr}](https://stringr.tidyverse.org/)

[regex101](https://regex101.com/)

["Strings" in _R for Data Science_](https://r4ds.had.co.nz/strings.html) by Hadley Wickham and Garrett Grolemund

["Strings and Dates" in _The R Cookbook_, 2nd ed.](https://rc2e.com/stringsanddates) by J.D. Long and Paul Teetor

["Regular Expressions" in _Supervised Machine Learning for Text Analysis in R_](https://smltar.com/regexp.html) by Emil Hvitfeldt and Julia Silge


Samuel E. Buttrey and Lyn R. Whitaker, _A Data Scientist's Guide to Acquiring, Cleaning and Managing Data in R_ (2017):

* Chapter 4, "R Data, Part 3: Text and Factors / 4.4 Regular Expressions"

* [UVic library link](https://learning-oreilly-com.ezproxy.library.uvic.ca/library/view/a-data-scientists/9781119080022/c04.xhtml)


