---
title: "Data manipulation"
subtitle: "Creating new variables"
output:
  html_document:
    df_print: paged
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->

```{r setup}
library(tidyverse)
#
library(stringr)  # {stringr} is part of the tidyverse, but not a core package that loads with {tidyverse}

# penguins dataset
library(palmerpenguins)
# Statistics Canada data from CANSIM
library(cansim)

```




## Objectives

* Understand the reasons for creating new variables

* Explore some approaches to creating new variables




There are a variety of reasons why you would want to create a new variable, and for every reason there's going to be a variety of ways to address the reason.

## 1. Ratio

Let's start with creating a new variable that is the result of two others in the same observation: a ratio

In the {palmerpenguin} data, there are two measures of the bird bills: bill length and bill depth. A thin pointy bill will have a small ratio of depth to length, and a larger ratio will look kind of stubby. Let's calculate the ratio of the two for every bird in the dataset:


```{r}

penguins

penguins %>%
  mutate(culmen_ratio = bill_depth_mm / bill_length_mm)

```

# 2. Distribution

We might also want to compare a single value to the average of the group. For example, we might want to compare the weight of each bird to the others of the same species. One comparison would be as a percentage of the averageâ€”is it 5% lighter or 10% heavier?

R's {dplyr} functions are designed for this sort of calculation.

While we could compare each bird to all of the others in the dataset, in this case we want to compare them within their species. First we group by species, then calculate a new variable with the `mutate()` function. Note that we have to use `na.rm = TRUE` in the `mean()` function.

Note: this is known as a _conditional transformation_, since the value is "conditioned" or "conditional" on the species.

```{r}

penguins %>% 
  mutate(body_mass_pct = body_mass_g / mean(body_mass_g, na.rm = TRUE) * 100) 


penguin_mass <- penguins %>% 
  group_by(species) %>% 
  mutate(body_mass_pct = body_mass_g / mean(body_mass_g, na.rm = TRUE) * 100) 

penguin_mass

penguin_mass %>% 
  arrange(body_mass_pct) %>% 
  select(species, sex, body_mass_g, body_mass_pct)


```

We could add more grouping variables, such as `sex`, to compare each bird to the same sex in their species.



```{r}

penguin_mass <- penguins %>% 
  group_by(species, sex) %>% 
  mutate(body_mass_pct = body_mass_g / mean(body_mass_g, na.rm = TRUE) * 100) 

penguin_mass

penguin_mass %>% 
  arrange(body_mass_pct) %>% 
  select(species, sex, body_mass_g, body_mass_pct)


```


Other measures of a value's position within a distribution include

* standardization (using the _z_ score)

* rank
  
  - percentile rank



## 3. Index

An index is used to measure change from a single point in time. This is a valuable tool for comparing growth rates when the absolute values are very different, and the differences in magnitude will obscure the growth rate differences.

For this example, let's compare the population growth in the Vancouver Census Metropolitan Region (CMA) to the Victoria CMA.

```{r}
# run this chunk to get the full data table from cansim
can_pop <- get_cansim("17-10-0135-01")
#
# Vancouver, both sexes, all ages: vector v1060818031
# Victoria, both sexes, all ages: vector v1060818691

pop_van_vic <- can_pop %>%
  mutate(REF_DATE = lubridate::ymd(REF_DATE, truncated = 2L)) %>%
  filter(VECTOR %in% c("v1060818031", "v1060818691"))

pop_van_vic <- pop_van_vic %>% 
  arrange(GEO) %>% 
  select(GEO, REF_DATE, VALUE)

pop_van_vic
```

```{r}
ggplot(pop_van_vic, aes(x = REF_DATE, y = VALUE, colour = GEO)) +
  geom_line(size = 1.2) +
  theme(legend.position="bottom") +
  ylim(0, 3000000)
  
```

If we use an index value, it allows for a direct comparison of the growth rates.

```{r}

pop_van_vic <- pop_van_vic %>% 
  group_by(GEO) %>% 
  mutate(index_val = first(VALUE)) %>% 
  mutate(index_2006 = VALUE / first(VALUE) *100) %>% 
  mutate(index_2011 = VALUE / nth(VALUE, 6) *100) %>% 
  ungroup()

pop_van_vic
```


```{r}
ggplot(pop_van_vic, aes(x = REF_DATE, y = index_2011, colour = GEO)) +
  geom_line(size = 1.2) +
  theme(legend.position="bottom")
  

```


Data source: https://www150.statcan.gc.ca/n1/pub/91-214-x/91-214-x2020001-eng.htm

## 4. Other {dplyr} functions for transformation

Some useful functions:

| function | what it does |
| ---- | ---- |
| `lead()` , `lag()` | computes lead or lag values |
| `nth()` , `first()` , `last()` | extract the first, last or nth value from a vector |
| `cumsum()` etc. | cumulative sum (in {base}) |
| `cumall()` , `cumany()` , `cummean()` | cumulative functions |



See: 

* {dplyr} "Vector functions": https://dplyr.tidyverse.org/reference/index.html#section-vector-functions

* {base} "Cumulative Sums, Products, and Extremes" https://stat.ethz.ch/R-manual/R-devel/library/base/html/cumsum.html




---

## REFERENCE


Nina Zumel and John Mount, _Practical Data Science with R (2nd edition)_ (2020)

* Chapter 4 "Managing Data" (4.2 Data transformations)

* [UVic library link](https://learning-oreilly-com.ezproxy.library.uvic.ca/library/view/practical-data-science/9781617295874/?ar?orpq&email=oJbr4Ho8VLXz0zbFzjLK2g%3d%3d&tstamp=1600527352&id=DC7689B4AD2FA446468DD1CE0CCCD91B187CD9C4)



