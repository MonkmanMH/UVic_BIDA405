---
title: "Manipulation of data tables"
subtitle: "sampling"
output:
  html_document:
    df_print: paged
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->

```{r setup}
library(tidyverse)
#

# datasets
library(nycflights13)
library(Lahman)
```

## Objectives

* understand the function of keys in relational databases

* understand how to join tables

* understand the primary types of mutating and filtering joins


## Relational data


Often, the data you are working with are spread across multiple tables. This allows for efficient database storage (there's an entire discipline dedicated to database theory and practical implementations of those theories.)

This requires you, the data analyst, to join tables, so that the information held in multiple tables can be used to answer the research question at hand.

For this hands-on exercise we will use the {nycflights13} package; this package contains airline on-time data for all flights departing NYC in 2013. It also includes useful 'metadata' on airlines, airports, weather, and planes.

In addition to `flights`, there are four other tables in the package:

* `airlines`

* `airports`

* `planes`

* `weather`

The tables are _related_ to `flights` by the fact that they have variables in common. These are known as the "key" variables.

This diagram shows the relationships:

![nycflights13](relational-nycflights.png)


## 1. Keys

1. Primary: identifies a unique observation in the table.

2. Foreign: a unique observation in another table, but not this one.

An example: `tailnum`

* _primary_ in `planes` -- there is only one observation for each aircraft

* _foreign_ in `flights` -- a plane could have multiple flights in and out of NYC airports


Having the same key in two tables forms the "relation" -- hence "relational database".


### Your turn 1.1

Use `count` to check that `planes$tailnum` is a primary key

```{r}
# solution (in _R4DS_)
planes %>% 
  count(tailnum) %>% 
  filter(n > 1)

# alternate solution
flights %>% 
  count(tailnum) %>% 
  summarise(max(n))


```


Sometimes tables don't have a primary key! When that happens, it can be useful to create one -- `mutate()` and `row_number()` is one approach. This is a _surrogate key_.


## 2. Mutating joins

The first kind of joins are "mutating joins" -- new variables are added to one data frame from matching observations in another.

## 2a. Understanding keys 

* from [_R for Data Science, "Understanding joins"]("https://r4ds.had.co.nz/relational-data.html#mutating-joins")

First, we will make two small tables, `x` and `y`

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)

y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)

x
y

```


**inner joins**

An inner join keeps only the observations where there is a match on both sides:

```{r}

inner_join(x, y, key = "key")

```


**left join**

Left, right, and full joins are varieties of "outer joins".

Join the two tables using a left join: ... all of the observations from the first table (on the left-hand side of the function), and variables from the matching records from the second (the right-hand side of the function).

The {dplyr} function for this is `left_join()`

```{r}
left_join(x, y, key = "key")
```

Note that all 3 of the `x` values are there; because there is no `y` observation with the key value of "3", the `val_y` value is `NA`.

**right join**

Is the same as a left join, but keeps all of the observations in `y`

**full join**

Keeps all of the observations in both `x` and `y`

### Your turn 2.1

See what happens when you join the tables with a `right_join()`, followed by a `full_join()`


```{r}
# solution
right_join(x, y, key = "key")

# solution
full_join(x, y, key = "key")
```





## 2.b Duplicate Keys - #1

In real life, tables start to get more complex. It's often the case that you will have tables that have duplicate keys in one or both of the tables.

The chunk below creates new versions of `x` and `y` tables, where there are duplicate keys in one.

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)

y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
```


### Your turn 2.3

Join the tables with `left_join()`, with `x` as the table on the left.

```{r}
# solution
x
y

left_join(x, y, key = "key")

```


A situation where there are duplicate keys in both tables is usually an error--there is no unique identifier of a single observation. (A question to ask yourself is "Is there are third table?")


### Your turn 2.4

Here's fresh versions of `x` and `y` tables, where the key "2" is duplicated in both.

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)

```


What does a left join do? How many rows does the resulting table have?

```{r}
# solution

left_join(x, y, by = "key")

```

```{r}

x %>% 
  distinct(key, .keep_all = TRUE)

```




***

## 3. Filtering joins

The other sort of joins filter observations from one data frame based on whether or not they match an observation in the other table.

There are two sorts: 

* `semi_join(x, y)` keeps all observations in `x` that have a match in `y`.

* `anti_join(x, y)` drops all observations in `x` that have a match in `y`.


Let's make some test tables again:


```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

Semi-join: only the observations in `x` that have a match in `y`.

Note that no variables from `y` appear in the result.

```{r}
semi_join(x, y, key = "key")
```


Anti-join: returns the observations in `x` that _don't_ have a key match in `y`. Again, no values from `y` appear in the result.

```{r}
anti_join(x, y, key = "key")
```



## 4. Joins with HR data
 
The Lahman baseball database contains a comprehensive listing of annual summaries for the major leagues of baseball, going back to 1871. 

For this exercise, we will use three of the tables:

* "People" -- all players

* "Salaries" -- an incomplete list of the annual summary of each player's compensation.
 
* "Batting" -- the annual summary of each player's batting. (Note: players who were traded between teams mid-season show up with a record for their performance of each team.)

Think of these as the sorts of files that you would find in any human resources department: 

* the People file contains the personal details of each individual employed by the enterprise.

* Batting contains in-depth performance measures for the employees in a specific task group

* Salaries is an incomplete tables showing the compensation of some of the employees


### 4a. Read in the three tables

Because the tables are in a package that we've loaded using `library()`, we can access the tables without loading them separately into the R environment.




### 4b. Understanding the tables


> i. What is the key variable that links the three tables?

A: playerID

The ID is unique so they donâ€™t need any other way to identify the players. Any other table can be joined with the players table for more information about a player.
 
> ii. Which table has the primary key? What is the reason behind your answer?

A: `People` has the primary key. It lists all individual players. The other dataframes potentially include multiple entries for each player ID. For example, a player might be traded mid-season and have two records in `Batting`, one for each team played for that season. 

> iii. Why would the designers of the table put only one variable in the Batting table that identifies a player?

A: Since all of the data in `People` is constant (name, birthdate, etc) there is no need to repeat those variables in the other tables where there are multiple records for the same player. It also means that this consistent data only has to be edited in one location, not across all of the tables.

### 4c. Joins

Join the tables in such a way so that you can tabulate the number of batters that played on each team in 2019, by birth country.


```{r}
# solution
MLB_HR_data <- Batting %>% 
  filter(yearID == 2019) %>% 
  left_join(People, by = "playerID")

MLB_HR_data

MLB_HR_data %>% 
  group_by(birthCountry, teamID) %>% 
  tally() 


# NOTES
#
# * both tables have the variable "playerID"
# 
# * we want a `left_join`: all the observations from the active season, and adding the country of birth variable from "People"
#
# * an `inner_join` will work for "Batting", with added "People" because all players are listed in both. 

```

### 4d. What was the Blue Jays' ROI?

Let's join the tables to calculate how much it cost the Blue Jays per run scored in 2016 (the last year for which there is salary data). Remember that this is incomplete, as the salary data is incomplete.

```{r}
jays_salaries <- Salaries %>%
  filter(yearID == 2016,
         teamID == "TOR") %>% 
  arrange(desc(salary))

jays_batting <- Batting %>% 
  filter(yearID == 2016,
         teamID == "TOR")

jays_roi <- jays_salaries %>% 
  left_join(jays_batting, by = "playerID")

jays_roi %>% 
  summarise(dollars = sum(salary),
            runs = sum(R),
            roi = dollars/runs)

```



***

## REFERENCE

This hands-on exercise draws heavily on the following sources:

* ["Relational data" at _R for Data Science_](https://r4ds.had.co.nz/relational-data.html)

* ["Join two tables" at the STAT545 site](https://stat545.com/join-cheatsheet.html)

{dplyr} reference page: https://dplyr.tidyverse.org/

* ["Two-table verbs", article at the {dplyr} website](https://dplyr.tidyverse.org/articles/two-table.html)

* ["Join two tbls together", part of the {dplyr} reference pages](https://dplyr.tidyverse.org/reference/join.html)



## Other references



Nina Zumel and John Mount, _Practical Data Science with R (2nd edition)_ (2020)

* Chapter 5 "Data Engineering and Data Shaping" (5.4 Multitable data transformations)

* [UVic library link](https://learning-oreilly-com.ezproxy.library.uvic.ca/library/view/practical-data-science/9781617295874/?ar?orpq&email=oJbr4Ho8VLXz0zbFzjLK2g%3d%3d&tstamp=1600527352&id=DC7689B4AD2FA446468DD1CE0CCCD91B187CD9C4)



### SQL

Thomas Nield, _Getting Started with SQL: A Hands-On Approach for Beginners_ (2016)

* Chapter 2, "Databases"

* Chapter 9, "Database design"

* Installing SQLite: Chapter 3, "SQLite"

* [UVic Library link](https://proquestcombo-safaribooksonline-com.ezproxy.library.uvic.ca/9781491938607?ar&orpq&email=oJbr4Ho8VLXz0zbFzjLK2g%3d%3d&tstamp=1600913295&id=2C359E41B596290424E03BF0F243BBA36BFDDBFA)



