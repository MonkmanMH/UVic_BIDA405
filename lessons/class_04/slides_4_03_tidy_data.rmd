---
title: "Data Structures"
subtitle: "_tidy data_"
author: "Martin Monkman"
date: "2020/09/26"
output:
  xaringan::moon_reader:
    css: [default, css_files/eigengrau.css, css_files/eigengrau-fonts.css]    
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```


class: inverse

# Our journey so far...

* Importing data
* Cleaning data
* Data manipulation


---
class: inverse


## Next: 

## Data structures



---

## What makes data tidy? 1/3

* Each variable must have its own column.

![each variable is a column](tidy-1a.png)

---

## What makes data tidy? 1/2

* Each observation must have its own row.

![each observation is a row](tidy-1b.png)
---

## What makes data tidy? 1/3

* Each value must have its own cell.

![value has cell](tidy-1c.png)

---
class: inverse

## A tidy example: penguins

```{r echo = FALSE, warning = FALSE}
library(palmerpenguins)
penguins
```

---
class: inverse

## `penguins` characteristics

* every variable is a column

* every observation is a row (the same penguin might be measured in multiple years)

* every cell has a single value 

---
class: inverse

## bonus `penguins` characteristics

* variable names are descriptive

  - including units

* variable names glob 

  - all variables about bills start with "bill_" 




---
class: inverse

## An untidy example


![untidy](alligator_untidy.jpg)


---
class: inverse

A logical step is to go beyond cleaning the data to _restructuring the data_

---
class: inverse

## The same data as relational tables


![tidy](alligator_tidy.jpg)
???

from Hart EM, Barmby P, LeBauer D, Michonneau F, Mount S, Mulrooney P, et al. (2016) Ten Simple Rules for Digital Data Storage. _PLoS Comput Biol_ 12(10): e1005097. https://doi.org/10.1371/journal.pcbi.1005097

---
class:inverse

![tidy](alligator_db_2.png)

---
class: inverse

Advantages of relational databases

* _normalization_ - separating the different types of data into their own tables

* reduces redundancy

* easier to maintain (only need to make changes in one place)

