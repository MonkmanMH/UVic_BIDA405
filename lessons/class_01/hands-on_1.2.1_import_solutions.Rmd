---
title: "Import data: CSV, TXT and Excel"
output: html_document
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 

Some of it comes straight from Hadley Wickham & Garrett Grolemund's book _R for Data Science_, found online here: https://r4ds.had.co.nz/

It uses great swaths of content adapted from the tidyverse reference material for {readr} and {readxl}, by RStudio. 
You can find that material here: 
https://readr.tidyverse.org/index.html 
https://readxl.tidyverse.org/index.html
-->


# Getting started

Run this code chunk:

```{r setup}
library(tidyverse)  # we will be using the functions of {readr}
library(readxl)
```



# 1. Reading a CSV file

CSV files are very commonly used for storing flat files. Unlike Excel, they don't have any formattingâ€”just the number or text in the cell.

"CSV" stands for "Comma Separated Values", letting you know that a comma is used to separate one variable from the next. You may also encounter Tab Separated Values, known as TSV files.

The **R** package {readr} is designed to make importing these files simple.


This example comes straight from the reference material for the {readr} package, found at https://readr.tidyverse.org/index.html


Run this code chunk to create an object called `mtcars`, from a CSV file of the same name.

```{r}
# example
mtcars <- read_csv("mtcars.csv")

```

Adding the `cols()` specification allows us to alter what {readr} has decided for us. For example, we could set the `cyl` variable to be an integer.


```{r}
# example
read_csv("mtcars.csv", 
         col_types = 
           cols(cyl = col_integer())
)

```


## Your Turn 1.1

Insert an R chunk and rerun the example above, but with the `am` and `gear` variables also set to integer.

```{r}
# solution
read_csv("mtcars.csv",
         col_types = 
           cols(cyl = col_integer(),
                am = col_integer(),
                gear = col_integer())
)

```




The {readr} package allows a lot of control over how the file is read. Of particular utility are 

* `na = ""` -- specify which values you want to be turned into `NA`

* `skip = 0` -- specify how many rows to skip 

* `n_max = Inf` -- the maximum number of records to read


## Your Turn 1.2

Read the first 5 rows of the "mtcars.csv" file.

```{r}
# solution
read_csv("mtcars.csv", 
         n_max = 5)


```



# 2. Reading a fixed-width file

Fixed-width files are a hold-over from the days when storage was expensive and/or on punch cards. This meant that specific columns in the table (or card) were assigned to a particular variable, and precious space was not consumed with a delimiter. Compression methods have since meant that a CSV file with unfixed variable lengths are more common, but in some big data applications, fixed-width files can be much more efficient.

If you ever have to deal with a fixed-width file, you will (or should!) receive a companion file letting you know the locations of each variable in every row.

In this example, we will use the one provided in the {readr} package, `fwf-sample.txt`. This simple file has four (or as we will see, sometimes three, if we combine first and last name as one) variables, and three records (or rows).

If we open the file in a text editor, we see this:

![fwf-sample.txt](names_img1.jpg)


The first approach would be to allow {readr} to guess where the column breaks are. Note that the column names are specified in a list. The `fwf_empty()` function looks through the specified file and returns the beginning and ending locations it has guessed, as well as the `skip` value that the `read_fwf()` function uses.

Note that {readr} will impute the variable type, as it did with the CSV file. And although we won't implement it in these examples, in the same way we can use the `col_types` specification, as well as `na`, `skip`, and others. See the `read_fwf` reference at https://readr.tidyverse.org/reference/read_fwf.html for all the details.

```{r}

read_fwf("fwf-sample.txt", fwf_empty("fwf-sample.txt", col_names = c("first", "last", "state", "ssn")))

```

So that worked, but it could break quite easily. We just need one person with a three or more components to their name (initials, spaces, or hyphens, as in [Ursula K. Le Guin](https://en.wikipedia.org/wiki/Ursula_K._Le_Guin) or [Ta-Nehisi Coates](https://en.wikipedia.org/wiki/Ta-Nehisi_Coates)), or some missing values, and the inconsistent structure throws off the parser.

```{r}

read_fwf("fwf-sample2.txt", fwf_empty("fwf-sample2.txt", col_names = c("first", "last", "state", "ssn")))

```

A more reliable approach is to specify exactly the width of each column. Note that in the example below, we specify only "name" without splitting it into first and last.

The variables and their widths are as follows:


Variable           Width   Start position   End position
--------           -----   --------------   ------------
name               20       1               20
state              10       21              30
ssn                12       31              42


Visually, the file looks like this (the digits across the top represent the column position):


![fwf-sample.txt](names_columns.png)


Those column positions can also be used to determine the width of each variable:


![fwf-sample.txt](names_arrows.png)

The widths can be added to the `fwf_widths` argument:

```{r}

read_fwf("fwf-sample2.txt", fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))

```

A third option is to provide two lists of locations using `fwf_positions()`, the first with the start positions, and the second with the end positions. The first variable "name" starts at position 1 and ends at position 20, and the second variable "ssn" starts at 30 and ends at 42. 

Note that we can choose to ignore columns that are not of interest to us; in this example we won't read the "state" variable which occupies the ten columns from 21 through 29.

```{r}
read_fwf("fwf-sample2.txt", fwf_positions(c(1, 31), c(20, 42), c("name", "ssn")))
```

The fourth is a syntactic variation on the third, with the same values but in a different order, using the `fwf_cols()` function. This time, all of the relevant information about each variable is grouped together, with the name followed by the start and end locations.

```{r}

read_fwf("fwf-sample2.txt", fwf_cols(name = c(1, 20), ssn = c(31, 42)))

```

And finally, {readr} provides a fifth way to read in a fixed-width file that is a variation on the second approach we saw, with the name and the width values aggregated.

```{r}

read_fwf("fwf-sample2.txt", fwf_cols(name = 20, state = 10, ssn = 12))

```


## An extreme example of a fixed-width file

Statistics Canada has made available a Public-Use Microdata File (PUMF) of the Joint Canada/United States Survey of Health, a telephone survey conducted in late 2002 and early 2003. There were 8,688 respondents to the survey, 3,505 Canadians and 5,183 Americans. The data file that's available is anonymized, so we have access to the individual responses, which will facilitate additional analysis.

The webpage for the survey, including the PUMF file, data dictionary, and methodological notes, is here:
https://www150.statcan.gc.ca/n1/pub/82m0022x/2003001/4069119-eng.htm

The PUMF is a fixed-width file. Compared to the names example above, this is _huge_. There are the 8,688 records to start with. But the data takes up 552 columns! 

Here's what the first two-and-a-bit records look like:

![_health survey data_](health_first10.PNG)

You can spot the end of each record, as the partial line. There's not a bit of white space anywhere in this data file!

Here's how one variable, highest level of post-secondary education achieved, appears in the data dictionary:


![_health survey example_](healthsurv_var_postsec.JPG)

The variable is 1 character long, in postion 502 of the data.

The researchers might look at the relationship between different health outcomes and education level, so this variable would be a important one to support that analysis. The variable is only 1 character long, but when coupled with the "content" column in the data dictionary, it becomes a very powerful piece of information. 

Imagine, though, the challenge of handling this amount of data at one time! Between the many variables and the complex value labels, the "data" is more than just the fixed-width file. This is a circumstance where a different data storage solution (as we will see later) might have some strengths.


# 3. Reading an Excel file

If anything, Excel files (with the .XLS or .XLSX extensions) are more common than CSV and other plain-text data files. They seem to multiply like coat hangers in the closet...

And as we see in the article by Karl Broman & Kara Woo, ["Data Organization in Spreadsheets"](https://www.tandfonline.com/doi/full/10.1080/00031305.2017.1375989), Excel files can encourage some ways of storing information that makes it hard for us to analyze. Excel files can also contain a wide variety of data format types. {readxl} tries to figure out what's going on, but like {readr}, it allows you to override some of those automatic decisions.


```{r}
deaths <- read_excel("deaths.xlsx")
deaths
```

What do you notice about the "Date of birth" and "Date of death" columns?


## Your Turn 2.1

Read in the "deaths" file, but use the `range = ` option to specify when to start reading the file:


```{r}
# Example
deaths <- read_excel("deaths.xlsx", 
                     range = "A1:B3")

deaths

# solution
deaths <- read_excel(
  "deaths.xlsx",
  range = "A5:F15"
)

deaths

```


Use the `skip =` and `n_max =` options to achieve the same thing:

```{r}

# solution
deaths <- read_excel(
  readxl_example("deaths.xlsx"),
  skip = 4,
  n_max = 10
)

deaths


```



## REFERENCE MATERIAL

_R for Data Science_, "Data Import":
https://r4ds.had.co.nz/data-import.html


_R Cookbook (2nd ed.)_, "Input and Output":
https://rc2e.com/inputandoutput



### Package reference pages

{readr} 
https://readr.tidyverse.org/

{readxl}
https://readxl.tidyverse.org/index.html

