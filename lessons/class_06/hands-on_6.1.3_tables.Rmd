---
title: "Tables"
subtitle: "Exercise: penguins"
output:
  html_document
---

<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->

```{r global options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```
```{r setup, message=FALSE, warning=FALSE}
# data wrangling
library(tidyverse)
library(readr)     # for read_csv()
library(magrittr)  # for pipes
# table formatting
library(kableExtra)
```

## Objectives

* Demonstrate (some of the many, many) options for formatting tables in R Markdown


## Population of Canada

Creating a table that looks like the one published by Statistics Canada.

(Source: Statistics Canada. [Table 17-10-0009-01 Population estimates, quarterly](https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1710000901))

![Canada, Quarterly Population](df_17100009_2020-10-08.JPG)


### data load

First, load the data

```{r}
df_17100009 <- read_csv("data/17100009.csv")
```

```{r}
head(df_17100009)
```

### filter

We want `GEO` and `VALUE`. We also want `REF_DATE`, but only the most recent 5 dates.  Time to select, and then filter.

```{r}
df_pop <- df_17100009 %>% 
  select(REF_DATE, GEO, VALUE)
head(df_pop)
```

Filtering the most recent 5 quarters.

Step 1: what are the last 5 quarters? To find the 5 largest values in any series, we can use `distinct` and then `slice_max()` from {dplyr}.

There are also other "slice" functions
https://dplyr.tidyverse.org/reference/slice.html

This returns a short dataframe with only those five rows.

```{r}
last_five_q <- df_pop %>% 
  distinct(REF_DATE) %>% 
  slice_max(REF_DATE, n = 5)
  
last_five_q
```

Step 2: 

Now we need to extract the values that are in the first (and only) column of our dataframe `last_five_q`. (See [Roger Peng, _R Programming for Data Science_ 9.1 Subsetting a Vector](https://bookdown.org/rdpeng/rprogdatascience/subsetting-r-objects.html))

```{r}
list_five <- last_five_q[[1]]
list_five
```

Step 3:

Now we can use that list to filter the dataframe.

```{r}
df_pop <- 
df_pop %>%
  filter(REF_DATE %in% list_five)
head(df_pop)
```

### pivot to wider

The next step is to pivot the table, in order to get the correct structure. For this, we need the package {tidyr} (part of the {tidyverse} package of packages) and the function `pivot_wider()`

```{r}
df_pop_pivot <- df_pop %>% 
  pivot_wider(id_cols = GEO, names_from = REF_DATE, values_from = VALUE)
df_pop_pivot
```

For another example of pivoting, see [R for Social Science at Data Carpentries](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html#"Reshaping with pivot_wider() and pivot_longer()")


## Table Formatting

At this point we can move on to formatting the table. In its basic knitted form it's a bit uninspiring, and not what we would want to use in a handout.


The first possible change is in the YAML: we can add

`output:`

  `html_document:`
  
    `df_print: paged`

to set a "paged" option to our dataframe output.


```{r}
df_pop_pivot
```

It doesn't look too bad, but it is "paged" at 10 rows, and has the variable type showing. It's not quite there yet.

The second option is to use the kable functions in {rmarkdown}. Again, we need to change the option in the YAML:

`output:`

  `html_document:`
  
    `df_print: kable`

This will print all 14 rows in a single view.


```{r}
df_pop_pivot 
```

### kable & {kableExtra} .

Using kable (part of {knitr}, which is behind R Markdown) and the package {kableExtra} opens up the possibility of a lot more formatting.

See this vignette for more details: https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html

Also the RMarkdown Cookbook has some good reference material: https://bookdown.org/yihui/rmarkdown-cookbook/kable.html

```{r}
df_pop_pivot %>% 
  kbl() %>% # to turn the dataframe into a kable object
  kable_paper("hover", full_width = TRUE)  # the "paper" option
```

In the following example, we will create a kable object which we can easily reference.

In that `kable()` function, we will first change the column names to be consistent with Statistics Canada. As well, the number formatting is set to have comma separators ("big.mark"), and no scientific notation.

Then with our new object we use the "striped" option for a "paper" table, bold the most recent column, and shade the British Columbia row.

```{r}
kbl_pop <- df_pop_pivot %>% 
  kable(col.names = c("Geography", 
                "Q3 2019", "Q4 2019", 
                "Q1 2020", "Q2 2020", "Q3 2020"), # change column names
        format.args = list(big.mark = ",", scientific = FALSE)) # change number formatting
kbl_pop %>%  
  kable_paper("striped", full_width = F) %>% # the "paper" option for style
  column_spec(6, bold = TRUE) %>% 
  row_spec(11, bold = TRUE, color = "#FFD800", background = "#002680") 
```



Note that if we want to make changes to the header row, we reference row number 0 in `row_spec()`. 

```{r}
kbl_pop %>%  
  kable_paper("striped", full_width = F) %>% 
  row_spec(0, bold = TRUE, color = "#FFD800", background = "#002680", font_size = 18)
```


There is an option to add a footnote to the table. Here I used a number, but there's also an option for `general`, `number`, `alphabet`, and `symbol`.

```{r}
kbl_pop %>%  
  kable_classic("striped", full_width = F) %>% 
  footnote(number = c("Source: Statistics Canada, Table 17-10-0009-01 Population estimates, quarterly",
                      "Downloaded 2020-10-07")) 
  
```


### Putting it all together

In this code chunk, we start with the unformatted pivot table, and add all of the formatting code from aboveâ€”plus grouping the provinces and territories, using the `pack_rows()` function.


```{r}
# create the initial kable object
kbl_pop <- df_pop_pivot %>% 
  kable(col.names = c("Geography", 
                "Q3 2019", "Q4 2019", 
                "Q1 2020", "Q2 2020", "Q3 2020"),
        format.args = list(big.mark = ",", scientific = FALSE))
# format-a-rama
kbl_pop %>%  
  # overall table style
  kable_classic("striped", full_width = F) %>% 
  # format header row
#  row_spec(0, bold = TRUE, color = "#ffffff", background = "#000000", font_size = 18) %>% 
  row_spec(0, bold = TRUE, font_size = 18) %>% 
  # BC row
  row_spec(11, italic = TRUE) %>%
  # most recent column
  column_spec(6, bold = TRUE) %>% 
  # footnotes (with symbol)
  footnote(symbol = c("Source: Statistics Canada, Table 17-10-0009-01 Population estimates, quarterly",
                      "Downloaded 2020-10-07")) %>% 
  # add grouping for provinces and territories
  pack_rows("Provinces", 2, 11) %>% 
  pack_rows("Territories", 12, 14)
  
```




There are many other options:

* conditional formatting

* tooltips and popover messages

* changing missing values from "NA" to another representation (for example, a hyphen or double asterix)



***

## REFERENCE

https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/

### Packages

A range of other packages for formatting tables:

**{flextable}**: [easily create tables for reporting and publications.](https://davidgohel.github.io/flextable/)

**{dt}**: [An R interface to the DataTables library](https://rstudio.github.io/DT/)

* "provides an R interface to the JavaScript library DataTables. R data objects (matrices or data frames) can be displayed as tables on HTML pages, and DataTables provides filtering, pagination, sorting, and many other features in the tables."


**{reactable}**: [Interactive data tables for R, based on the React Table library and made with reactR.](https://glin.github.io/reactable/)

**{huxtable}**: [an R package to create LaTeX and HTML tables](https://hughjonesd.github.io/huxtable/)

**{pixiedust}**: [_Get Your Sparkle On: A Guide to Using the Magic of pixiedust_](https://www.suchanutter.net/pixiedust/)

---

## A strategy for automating the column headers

Above, we hard-coded the header titles for each quarter. What follows is a strategy to automatically generate those headings.

Let's use `case_when` to create our quarter variable, and split out the year.

```{r}
df_pop_2 <- df_pop %>%
  mutate(YEAR = str_sub(REF_DATE, 1, 4)) %>% 
  mutate(QUARTER = case_when(
    "01" == str_sub(REF_DATE, 6, 7) ~ "Q1",
    "04" == str_sub(REF_DATE, 6, 7) ~ "Q2",
    "07" == str_sub(REF_DATE, 6, 7) ~ "Q3",
    "10" == str_sub(REF_DATE, 6, 7) ~ "Q4",
    TRUE ~ NA_character_
  ))

df_pop_2
```

Next, the two new variables are pasted together in the correct order. 

* [{glue} package](https://glue.tidyverse.org/index.html)

We will then assign them as factor variables, which preserves their order (because alphabetically they will be mixed up, with "Q1 2019" followed by "Q1 2020", then "Q2 2019" etc).

* [{forcats} package](https://forcats.tidyverse.org/index.html)

* [Programming with R: Understanding Factors](https://swcarpentry.github.io/r-novice-inflammation/12-supp-factors/index.html)

* [_R for Data Science_, Factors](https://r4ds.had.co.nz/factors.html)

Note that this uses a different pipe symbol from the {magrittr} package, which returns the results of the pipe to the same object.

* [{magrittr}](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)


```{r}

df_pop_2 %<>%
  mutate(QY = glue::glue('{QUARTER} {YEAR}')) %>% 
  mutate(QY = forcats::as_factor(QY)) 

levels(df_pop_2$QY)

```

```{r}

df_pop_2

```

Now we can drop the extra columns and pivot:


```{r}
df_pop_pivot_2 <- df_pop_2 %>% 
  select(Geography = GEO,       # rename field
         QY, VALUE) %>% 
  pivot_wider(id_cols = Geography, names_from = QY, values_from = VALUE)
df_pop_pivot_2
```



-30-